Start Date - 17th of May 2024
Time spent - At least 3 hours.  
# TODO list for this chapter.
- [ ] Hash Tables Breakdown and Implementation 🔽
- [ ] Resizing Array implementation and Circular Array 🔼 
- [ ] Matrix type DSA question help
- [ ] Problems 1 to 9 ⏫  

## Hash Table, wtf is a Hash function and why we need it
A Hash table is a very fundamental data structure that helps in myriad of problems and critical to many solutions. It is a DS that provides a **mapping** from **keys** to **values** using a technique called **hashing**. 
**Constraints**
- Keys must be unique, but other than that they can be any value, **as long as the keys are hashable** (more on this later)
- Values can be repeated.  
**Common use-case**
- Frequency Table -> Counting the each individual characters. It can also be a whole word.  
The second part of this puzzle is the **hash function**. A hash function **H**(x) is a function that maps a key **x** to a whole number. 
- For example -> **H(x) = (x$^2$ + 6x + 9) mod 10** maps all integer values to the range of [0,9]
- Same can be done with any objects. If the key is a string for example, compute and sum all the ASCII values with Mod {size of hash table} to get a key.
## Properties of Hash Functions
If h(x) == h(y), then x and y **might be equal** (we still need to compute and check it), but **if h(x) != h(y), then x is definitely not equal to y**.

This is very crucial as it lets us compare very large files and quickly find out at least they aren't equal without actually scanning or viewing the file. The H(x) and H(y) are already computed when information is inserted in a hash table so the operation is O(1). In file systems we use very sophisticated hash functions like checksums.

Another property is **hash function must absoulutly be deterministic.**\
]=-[0pio## Discussion on collision resolution methods

### Separate Chaining
### Open Addressing 

## Complexity analysis

## Separate chaining implementation details


### Question 1.4 Palindrome Permutation
1. Listen - The condition doesn't include non alphabetic characters and is not case sensitive. The result is just Boolean so we can manipulate the data in place if we wish. 
2. Example - 
	1. "Tact Coa" -> "taco cat", "atco cta", etc -> True
	2. "racecar" -> True
	3. "" -> False 
	4. "aaaaa" -> True
3. Bruteforce - 
	1. Psuedocode -
		1. Create a hash map to store character count
		2. Iterate the map to find two condtions
		3. if the count is odd, set a boolean is odd found to true. we can only afford one character to be an odd number.
		4. if the count is odd and isoddfound is true return false.
		5. or else keep continue.
		6. return true at the end.
		```java
		boolean checkUnique(String str) {
			boolean isOddFound = false;
			Map<Character, Integer> map = new HashMap<>();
			for (char c: str.toCharArray()) {
				map.put(c, map.getOrDefault(c, 0) + 1);
			}
			for (Map.entry<Character, Integer> entry: map.entrySet()) {
				if (isOddFound && entry.getValue() % 2 > 0) {
					return false;
				} else if (entry.getValue() % 2 > 0) {
					isOddFound = true
				} else continue;
			}
			return true;
		}
	```
### Question 1.5 One away
##### Step 1: Listen
We understand there are three different conditions for the problem. Condition to check if strings can be made the same by the following - 
1. Inserting a Character -> Two pointers -> Check which string is shorter -> Loop through both of them until every character matches -> if false in the longer string move pointer by one to see if the string still matches -> if so countinue with boolean marker -> another similar condition terminate loop to tell insert is not the fix.
2. Removing a Character -> Same process almost (Maybe can be done in same loop)
3. Replacing a Character -> Same process but instead of moving the pointer, we just mark it.
##### Step 2: Example
##### Step 3: Bruteforce
```java
public boolean OneEdit(String s, String t) {

	// Step 1: Identify the shorter string
	String short = s.length() < t.length() ? s : t;
	String long = t.length() < s.length() ? t : s;

	// Insert Check and Remove check
	int shortPtr = 0, longPtr = 0;
	boolean isEdit = true;
	for (shortPtr = 0; shortPtr < short.length(); shortPtr++) {
		if (short.charAt(shortPtr) == long.charAt(longPtr)) {
			longPtr++;
			continue;
		} else if (short.charAt(shortPtr) != long.charAt(longPtr) && isInsertPossible) {
			longPtr++;
			if (short.charAt(shortPtr) == long.charAt(longPtr)) {
				isInsertPossible = false;
				continue;
			}
		} else {
			return false;
		}
	}

}
```